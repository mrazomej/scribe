"""
viz_hydra.py

This script is an entry point for visualizing the results of probabilistic model
inference runs in the SCRIBE framework. It is designed to be executed via Hydra,
a configuration management system, and expects as input a configuration file
describing the data, model, and inference parameters.

Key functionalities and workflow:

1. **Hydra Integration**:
   The script uses Hydra to manage configuration files. It is decorated with
   `@hydra.main`, which handles configuration parsing and working directory
   management, making it easy to reproduce results and manage output
   directories.

2. **Automatic Run Directory Resolution**:
   Based on the current Hydra configuration, the script reconstructs the path to
   the output directory that would have been generated by a prior model run.
   This ensures that visualizations access the correct results corresponding to
   the configuration parameters.

3. **Configuration Parsing**:
   The script extracts relevant information from the configuration (such as
   model type, inference method, parameterization, and data name). This data is
   used to standardize visualizations, plot filenames, and select results for
   plotting.

4. **Result Loading and Visualization**:
   While the full code (outside this docstring) handles result loading and
   plotting, the script delegates most of this functionality to a utility module
   (`viz_utils.py`). Functions like `plot_loss`, `plot_ecdf`, and `plot_ppc` are
   imported and then called to generate and save standardized figures‚Äîsuch as
   loss curves, ECDF plots, and posterior predictive checks‚Äîto the output
   directory.

5. **Error Checking**:
   If the expected run directory (from a previous inference job) does not exist,
   the script prints an error message and exits, prompting the user to first run
   inference.

6. **Extensibility**:
   The script is designed to be run as a standalone Hydra job, supporting
   extensions to additional plotting routines or diagnostics by simply updating
   `viz_utils.py` or the configuration files.

This structure helps users and downstream analysts quickly regenerate
standardized diagnostic and results visualizations‚Äîensuring consistency,
reproducibility, and ease of use in SCRIBE model workflows.

Typical usage:
    $ python viz_hydra.py data=your_data_name inference=your_inference_method etc...

This will use Hydra to load the default or user-specified configuration,
auto-detect the corresponding results directory, and generate loss history,
ECDF, and posterior predictive check plots.
"""

import hydra
from omegaconf import DictConfig, OmegaConf
import scribe
import pandas as pd
import jax.numpy as jnp
import pickle
import os
import matplotlib.pyplot as plt
import seaborn as sns
import scanpy as sc
import numpy as np
import warnings
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from viz_utils import (
    plot_loss,
    plot_ecdf,
    plot_ppc,
    plot_umap,
    plot_correlation_heatmap,
    plot_mixture_ppc,
)

console = Console()

# Suppress scanpy/anndata deprecation warnings
warnings.filterwarnings("ignore", category=FutureWarning, module="scanpy")
warnings.filterwarnings("ignore", category=FutureWarning, module="anndata")

# ------------------------------------------------------------------------------


@hydra.main(version_base=None, config_path="conf", config_name="config")
def main(cfg: DictConfig) -> None:
    console.print()
    console.print(
        Panel.fit(
            "[bold bright_magenta]üé® SCRIBE VISUALIZATION PIPELINE[/bold bright_magenta]",
            border_style="bright_magenta",
        )
    )
    console.print(
        f"[dim]üìÅ Working directory:[/dim] [cyan]{os.getcwd()}[/cyan]"
    )
    console.print("\n[bold]üìã Configuration:[/bold]")
    config_yaml = OmegaConf.to_yaml(cfg)
    syntax = Syntax(config_yaml, "yaml", theme="monokai", line_numbers=False)
    console.print(syntax)

    # ==========================================================================
    # Directory Detection Section
    # ==========================================================================
    console.print()
    console.print(
        Panel.fit(
            "[bold bright_cyan]üîç DETECTING INFERENCE RESULTS[/bold bright_cyan]",
            border_style="bright_cyan",
        )
    )

    # Auto-detect the run directory based on the same Hydra path structure
    # that would have been used for the original inference run
    from hydra.core.hydra_config import HydraConfig

    hydra_cfg = HydraConfig.get()

    # Check if run_dir is explicitly set in viz config
    viz_cfg = getattr(cfg, "viz", None)
    # Use OmegaConf.is_missing to safely check for ??? placeholder
    run_dir_set = False
    if viz_cfg and "run_dir" in viz_cfg:
        try:
            run_dir_value = viz_cfg.run_dir
            if run_dir_value is not None and run_dir_value != "???":
                run_dir = hydra.utils.to_absolute_path(run_dir_value)
                console.print(
                    f"[dim]üìÇ Using explicit run_dir from config:[/dim] [cyan]{run_dir}[/cyan]"
                )
                run_dir_set = True
        except Exception:
            # run_dir is missing or set to ???
            pass

    if not run_dir_set:
        # Construct the expected output directory path using the same logic as the
        # original config
        # This mirrors the hydra.run.dir pattern:
        # outputs/${data.name}/${inference.method}/${hydra:job.override_dirname}
        base_output_dir = "outputs"
        data_name = cfg.data.name
        inference_method = cfg.inference.method

        # Get the override dirname from current hydra config
        # Filter out viz.* parameters since they don't affect inference results location
        override_dirname = hydra_cfg.job.override_dirname
        if override_dirname:
            # Remove viz.* parameters from override_dirname
            override_parts = override_dirname.split(",")
            filtered_parts = [
                part
                for part in override_parts
                if not part.strip().startswith("viz.")
            ]
            override_dirname = (
                ",".join(filtered_parts) if filtered_parts else ""
            )

        # Construct the expected run directory
        run_dir = os.path.join(
            base_output_dir, data_name, inference_method, override_dirname
        )
        run_dir = hydra.utils.to_absolute_path(run_dir)

    console.print("[dim]üîç Auto-detecting run directory...[/dim]")
    console.print(f"[dim]üìÇ Expected directory:[/dim] [cyan]{run_dir}[/cyan]")

    # Check if the directory exists
    if not os.path.exists(run_dir):
        console.print(
            "[bold red]‚ùå ERROR: Run directory does not exist![/bold red]"
        )
        console.print(f"[red]   Missing:[/red] [cyan]{run_dir}[/cyan]")
        console.print(
            "[yellow]üí° Make sure you've run the inference first with the same "
            "configuration.[/yellow]"
        )
        return

    console.print("[green]‚úÖ Run directory found![/green]")

    # ==========================================================================
    # Results Loading Section
    # ==========================================================================
    console.print()
    console.print(
        Panel.fit(
            "[bold bright_blue]üìä LOADING INFERENCE RESULTS[/bold bright_blue]",
            border_style="bright_blue",
        )
    )

    # Create figs directory
    figs_dir = os.path.join(run_dir, "figs")
    os.makedirs(figs_dir, exist_ok=True)
    console.print(f"[dim]üìÅ Figures directory:[/dim] [cyan]{figs_dir}[/cyan]")

    # Load scribe results
    results_file = os.path.join(run_dir, "scribe_results.pkl")
    console.print(
        f"[dim]üì¶ Loading results from:[/dim] [cyan]{results_file}[/cyan]"
    )
    with open(results_file, "rb") as f:
        results = pickle.load(f)
    console.print("[green]‚úÖ Results loaded successfully![/green]")

    # Load original config from the run directory
    orig_cfg_file = os.path.join(run_dir, ".hydra", "config.yaml")
    if not os.path.exists(orig_cfg_file):
        console.print(
            "[bold red]‚ùå ERROR: Original config file not found![/bold red]"
        )
        console.print(f"[red]   Missing:[/red] [cyan]{orig_cfg_file}[/cyan]")
        return

    console.print(
        f"[dim]üìã Loading original config from:[/dim] [cyan]{orig_cfg_file}[/cyan]"
    )
    orig_cfg = OmegaConf.load(orig_cfg_file)
    console.print("[green]‚úÖ Original config loaded successfully![/green]")

    # ==========================================================================
    # Data Loading Section
    # ==========================================================================
    console.print()
    console.print(
        Panel.fit(
            "[bold bright_cyan]üìä LOADING ORIGINAL DATA[/bold bright_cyan]",
            border_style="bright_cyan",
        )
    )

    # Load data using the original config's data settings
    data_path = hydra.utils.to_absolute_path(orig_cfg.data.path)
    console.print(f"[dim]üìÇ Loading data from:[/dim] [cyan]{data_path}[/cyan]")
    counts = scribe.data_loader.load_and_preprocess_anndata(
        data_path, orig_cfg.data.get("preprocessing")
    )
    console.print(
        f"[green]‚úÖ Data loaded successfully![/green] [dim]Shape:[/dim] {counts.shape}"
    )

    # ==========================================================================
    # Visualization Setup Section
    # ==========================================================================
    console.print()
    console.print(
        Panel.fit(
            "[bold bright_magenta]üé® VISUALIZATION SETUP[/bold bright_magenta]",
            border_style="bright_magenta",
        )
    )

    # Set plotting style
    console.print("[dim]üé® Setting up matplotlib style...[/dim]")
    scribe.viz.matplotlib_style()

    # Get visualization settings from current config or use defaults
    viz_cfg = getattr(cfg, "viz", None)
    if viz_cfg is None:
        # Use default visualization settings
        viz_cfg = OmegaConf.create(
            {
                "loss": True,
                "ecdf": True,
                "ppc": True,
                "format": "png",
                "ecdf_opts": {"n_genes": 25},
                "ppc_opts": {"n_genes": 25, "n_samples": 1500},
            }
        )
        console.print("[dim]‚öôÔ∏è  Using default visualization settings[/dim]")
    else:
        console.print("[dim]‚öôÔ∏è  Using custom visualization settings[/dim]")
        if hasattr(viz_cfg, "ppc_opts") and hasattr(
            viz_cfg.ppc_opts, "n_genes"
        ):
            console.print(
                f"[dim]   PPC n_genes:[/dim] {viz_cfg.ppc_opts.n_genes}"
            )

    # ==========================================================================
    # Plot Generation Section
    # ==========================================================================
    console.print()
    console.print(
        Panel.fit(
            "[bold bright_yellow]üìà GENERATING PLOTS[/bold bright_yellow]",
            border_style="bright_yellow",
        )
    )

    plots_generated = []

    # --- Plotting functions will be called here based on viz config ---
    if viz_cfg.get("loss", True):
        console.print("[dim]üìà Generating loss history plot...[/dim]")
        plot_loss(results, figs_dir, orig_cfg, viz_cfg)
        plots_generated.append("loss")

    if viz_cfg.get("ecdf", True):
        console.print("[dim]üìä Generating ECDF plot...[/dim]")
        plot_ecdf(counts, figs_dir, orig_cfg, viz_cfg)
        plots_generated.append("ECDF")

    if viz_cfg.get("ppc", True):
        console.print(
            "[dim]üîç Generating posterior predictive check plots...[/dim]"
        )
        plot_ppc(results, counts, figs_dir, orig_cfg, viz_cfg)
        plots_generated.append("PPC")

    if viz_cfg.get("umap", False):
        console.print("[dim]üó∫Ô∏è  Generating UMAP projection plot...[/dim]")
        plot_umap(results, counts, figs_dir, orig_cfg, viz_cfg)
        plots_generated.append("UMAP")

    if viz_cfg.get("heatmap", False):
        console.print("[dim]üî• Generating correlation heatmap...[/dim]")
        plot_correlation_heatmap(results, figs_dir, orig_cfg, viz_cfg)
        plots_generated.append("Correlation Heatmap")

    if viz_cfg.get("mixture_ppc", False) and orig_cfg.get(
        "mixture_model", False
    ):
        console.print(
            "[dim]üß¨ Generating mixture model PPC (genes differing between components)...[/dim]"
        )
        plot_mixture_ppc(results, counts, figs_dir, orig_cfg, viz_cfg)
        plots_generated.append("Mixture PPC")

    # ==========================================================================
    # Completion Summary
    # ==========================================================================
    console.print()
    console.print(
        Panel.fit(
            "[bold bright_green]üéâ VISUALIZATION COMPLETED SUCCESSFULLY![/bold bright_green]",
            border_style="bright_green",
        )
    )
    console.print(f"[dim]üìÅ Results directory:[/dim] [cyan]{run_dir}[/cyan]")
    console.print(f"[dim]üé® Figures directory:[/dim] [cyan]{figs_dir}[/cyan]")
    plots_str = ", ".join(plots_generated) if plots_generated else "None"
    console.print(f"[dim]üìä Plots generated:[/dim] [bold]{plots_str}[/bold]")
    console.print()


if __name__ == "__main__":
    main()
