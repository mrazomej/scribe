

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scribe.models_mix &mdash; SCRIBE  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            SCRIBE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickoverview.html">Quick Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Available Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../models/index.html">Models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../results.html">Results Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SCRIBE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scribe.models_mix</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scribe.models_mix</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mixture model implementations for single-cell RNA sequencing data.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>
<span class="kn">import</span> <span class="nn">jax.scipy</span> <span class="k">as</span> <span class="nn">jsp</span>
<span class="kn">import</span> <span class="nn">numpyro</span>
<span class="kn">import</span> <span class="nn">numpyro.distributions</span> <span class="k">as</span> <span class="nn">dist</span>
<span class="kn">from</span> <span class="nn">numpyro.distributions</span> <span class="kn">import</span> <span class="n">constraints</span>

<span class="c1"># Import model config</span>
<span class="kn">from</span> <span class="nn">.model_config</span> <span class="kn">import</span> <span class="n">ModelConfig</span>

<span class="c1"># Import typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Negative Binomial-Dirichlet Multinomial Mixture Model</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="nbdm_mixture_model">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.nbdm_mixture_model">[docs]</a>
<span class="k">def</span> <span class="nf">nbdm_mixture_model</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpyro mixture model for single-cell RNA sequencing data using Negative</span>
<span class="sd">    Binomial distributions with shared p parameter per component.</span>
<span class="sd">    </span>
<span class="sd">    This model assumes a hierarchical mixture structure where:</span>
<span class="sd">        1. Each mixture component has:</span>
<span class="sd">           - A shared success probability p across all genes</span>
<span class="sd">           - Gene-specific dispersion parameters r</span>
<span class="sd">        2. The mixture is handled using Numpyro&#39;s MixtureSameFamily</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int</span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    model_config : ModelConfig</span>
<span class="sd">        Model configuration object containing distribution and parameter settings</span>
<span class="sd">    counts : array-like, optional</span>
<span class="sd">        Observed counts matrix of shape (n_cells, n_genes).</span>
<span class="sd">        If None, generates samples from the prior.</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic variational inference.</span>
<span class="sd">        If None, uses full dataset.</span>

<span class="sd">    Model Structure</span>
<span class="sd">    --------------</span>
<span class="sd">    Global Parameters:</span>
<span class="sd">        - Mixture weights ~ model_config.mixing_distribution_model</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_model</span>
<span class="sd">        - Component-specific dispersion r ~ model_config.r_distribution_model per gene and component</span>

<span class="sd">    Likelihood: counts ~ MixtureSameFamily(</span>
<span class="sd">        Categorical(mixing_weights), NegativeBinomialProbs(r, p)</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Sample mixing weights from Dirichlet prior</span>
    <span class="n">mixing_probs</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_model</span>
    <span class="p">)</span>
    
    <span class="c1"># Create mixing distribution</span>
    <span class="n">mixing_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">probs</span><span class="o">=</span><span class="n">mixing_probs</span><span class="p">)</span>

    <span class="c1"># Define the prior on the p parameters - one for each component</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_model</span><span class="p">)</span>

    <span class="c1"># Define the prior on the r parameters - one for each gene and component</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_model</span><span class="o">.</span><span class="n">expand</span><span class="p">([</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># Create base negative binomial distribution</span>
    <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Create mixture distribution</span>
    <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">base_dist</span><span class="p">)</span>

    <span class="c1"># If we have observed data, condition on it</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If batch size is not provided, use the entire dataset</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Define plate for cells</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mini-batch version</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span>
                <span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">,</span> <span class="n">subsample_size</span><span class="o">=</span><span class="n">batch_size</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">idx</span><span class="p">:</span>
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Predictive model (no obs)</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
            <span class="c1"># Sample counts from mixture</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)</span></div>



<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Variational Guide for Negative Binomial-Dirichlet Multinomial Mixture Model</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="nbdm_mixture_guide">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.nbdm_mixture_guide">[docs]</a>
<span class="k">def</span> <span class="nf">nbdm_mixture_guide</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Variational guide for the NBDM mixture model.</span>

<span class="sd">    This guide function defines the form of the variational distribution that</span>
<span class="sd">    will be optimized to approximate the true posterior. It specifies a</span>
<span class="sd">    mean-field variational family where each parameter has its own independent</span>
<span class="sd">    distribution:</span>

<span class="sd">    - The mixing weights follow a Dirichlet distribution</span>
<span class="sd">    - The success probability p follows a Beta distribution </span>
<span class="sd">    - Each gene&#39;s overdispersion parameter r follows an independent distribution</span>
<span class="sd">      (typically Gamma or LogNormal)</span>

<span class="sd">    The specific distributions used are configured via the model_config</span>
<span class="sd">    parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int</span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    model_config : ModelConfig</span>
<span class="sd">        Configuration object specifying the model structure and distributions</span>
<span class="sd">    counts : array_like, optional</span>
<span class="sd">        Observed counts matrix of shape (n_cells, n_genes)</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic optimization. If None, uses full dataset.</span>

<span class="sd">    Guide Structure</span>
<span class="sd">    --------------</span>
<span class="sd">    Variational Parameters:</span>
<span class="sd">        - Mixing weights ~ model_config.mixing_distribution_guide</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_guide</span>
<span class="sd">        - Component-specific dispersion r ~ model_config.r_distribution_guide per gene and component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Extract mixing distribution values</span>
    <span class="n">mixing_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract mixing distribution parameters and constraints</span>
    <span class="n">mixing_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">mixing_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">mixing_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">mixing_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;mixing_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">mixing_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract p distribution values</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract p distribution parameters and constraints</span>
    <span class="n">p_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">p_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">p_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;p_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">p_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract r distribution values</span>
    <span class="n">r_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract r distribution parameters and constraints </span>
    <span class="n">r_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">r_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">r_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;r_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">))</span> <span class="o">*</span> <span class="n">r_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Sample from variational distributions</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span> 
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">mixing_params</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">p_params</span><span class="p">))</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">r_params</span><span class="p">))</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Zero-Inflated Negative Binomial Mixture Model</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="zinb_mixture_model">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.zinb_mixture_model">[docs]</a>
<span class="k">def</span> <span class="nf">zinb_mixture_model</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpyro mixture model for Zero-Inflated Negative Binomial single-cell RNA</span>
<span class="sd">    sequencing data.</span>
<span class="sd">    </span>
<span class="sd">    This model uses the configuration defined in model_config. It implements a</span>
<span class="sd">    mixture of Zero-Inflated Negative Binomial distributions where each</span>
<span class="sd">    component has:</span>
<span class="sd">        - A shared success probability p across all genes</span>
<span class="sd">        - Gene-specific dispersion parameters r</span>
<span class="sd">        - Gene-specific dropout probabilities (gate)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int</span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    model_config : ModelConfig</span>
<span class="sd">        Configuration object for model distributions containing:</span>
<span class="sd">            - mixing_distribution_model: Distribution for mixture weights</span>
<span class="sd">            - p_distribution_model: Distribution for success probability p</span>
<span class="sd">            - r_distribution_model: Distribution for dispersion parameters r</span>
<span class="sd">            - gate_distribution_model: Distribution for dropout probabilities</span>
<span class="sd">    counts : array-like, optional</span>
<span class="sd">        Observed counts matrix of shape (n_cells, n_genes). If None, generates</span>
<span class="sd">        samples from the prior.</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic optimization. If None, uses full dataset.</span>

<span class="sd">    Model Structure</span>
<span class="sd">    --------------</span>
<span class="sd">    Parameters:</span>
<span class="sd">        - Mixture weights ~ model_config.mixing_distribution_model</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_model</span>
<span class="sd">        - Gene-specific dispersion r ~ model_config.r_distribution_model</span>
<span class="sd">        - Dropout probabilities gate ~ model_config.gate_distribution_model</span>

<span class="sd">    Likelihood: </span>
<span class="sd">        counts ~ MixtureSameFamily(</span>
<span class="sd">            Categorical(mixing_weights), </span>
<span class="sd">            ZeroInflatedNegativeBinomial(r, p, gate)</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Sample mixing weights from Dirichlet prior</span>
    <span class="n">mixing_probs</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_model</span>
    <span class="p">)</span>
    
    <span class="c1"># Create mixing distribution</span>
    <span class="n">mixing_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">probs</span><span class="o">=</span><span class="n">mixing_probs</span><span class="p">)</span>

    <span class="c1"># Define the prior on the p parameters - one for each component</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_model</span><span class="p">)</span>

    <span class="c1"># Define the prior on the r parameters - one for each gene and component</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_model</span><span class="o">.</span><span class="n">expand</span><span class="p">([</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># Define the prior on the gate parameters - one for each gene and component</span>
    <span class="n">gate</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;gate&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_model</span><span class="o">.</span><span class="n">expand</span><span class="p">([</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># Create base negative binomial distribution</span>
    <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    
    <span class="c1"># Create zero-inflated distribution</span>
    <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span><span class="n">base_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Create mixture distribution</span>
    <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">zinb</span><span class="p">)</span>

    <span class="c1"># If we have observed data, condition on it</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If batch size is not provided, use the entire dataset</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Define plate for cells</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mini-batch version</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span>
                <span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">,</span> <span class="n">subsample_size</span><span class="o">=</span><span class="n">batch_size</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">idx</span><span class="p">:</span>
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Predictive model (no obs)</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
            <span class="c1"># Sample counts from mixture</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)</span></div>



<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Variational Guide for Zero-Inflated Negative Binomial Mixture Model</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="zinb_mixture_guide">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.zinb_mixture_guide">[docs]</a>
<span class="k">def</span> <span class="nf">zinb_mixture_guide</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define the variational distribution for stochastic variational inference.</span>
<span class="sd">    </span>
<span class="sd">    This guide defines the variational distributions for the ZINB mixture model</span>
<span class="sd">    parameters using the configuration specified in model_config.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int</span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    model_config : ModelConfig</span>
<span class="sd">        Configuration object containing the variational distribution</span>
<span class="sd">        specifications:</span>
<span class="sd">            - mixing_distribution_guide: Distribution for mixture weights</span>
<span class="sd">            - p_distribution_guide: Distribution for success probability p</span>
<span class="sd">            - r_distribution_guide: Distribution for dispersion parameters r</span>
<span class="sd">            - gate_distribution_guide: Distribution for dropout probabilities</span>
<span class="sd">    counts : array_like, optional</span>
<span class="sd">        Observed counts matrix of shape (n_cells, n_genes)</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic optimization</span>

<span class="sd">    Guide Structure</span>
<span class="sd">    --------------</span>
<span class="sd">    Variational Parameters:</span>
<span class="sd">        - Mixture weights ~ model_config.mixing_distribution_guide</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_guide</span>
<span class="sd">        - Gene-specific dispersion r ~ model_config.r_distribution_guide</span>
<span class="sd">        - Gene-specific dropout gate ~ model_config.gate_distribution_guide</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Extract mixing distribution values</span>
    <span class="n">mixing_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract mixing distribution parameters and constraints</span>
    <span class="n">mixing_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">mixing_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">mixing_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">mixing_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;mixing_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">mixing_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract p distribution values</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract p distribution parameters and constraints</span>
    <span class="n">p_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">p_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">p_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;p_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">p_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract r distribution values</span>
    <span class="n">r_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract r distribution parameters and constraints </span>
    <span class="n">r_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">r_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">r_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;r_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">))</span> <span class="o">*</span> <span class="n">r_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract gate distribution values</span>
    <span class="n">gate_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract gate distribution parameters and constraints</span>
    <span class="n">gate_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">gate_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">gate_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">gate_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;gate_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">))</span> <span class="o">*</span> <span class="n">gate_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Sample from variational distributions</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span> 
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">mixing_params</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">p_params</span><span class="p">))</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">r_params</span><span class="p">))</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;gate&quot;</span><span class="p">,</span> 
        <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">gate_params</span><span class="p">)</span>
    <span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Negative Binomial Mixture Model with Variable Capture Probability</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="nbvcp_mixture_model">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.nbvcp_mixture_model">[docs]</a>
<span class="k">def</span> <span class="nf">nbvcp_mixture_model</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpyro mixture model for single-cell RNA sequencing data using Negative</span>
<span class="sd">    Binomial distributions with variable capture probability.</span>
<span class="sd">    </span>
<span class="sd">    This model assumes a hierarchical mixture structure where:</span>
<span class="sd">        1. Each mixture component has:</span>
<span class="sd">            - A shared success probability p across all genes</span>
<span class="sd">            - Gene-specific dispersion parameters r</span>
<span class="sd">        2. Each cell has:</span>
<span class="sd">            - A cell-specific capture probability p_capture (independent of</span>
<span class="sd">              components)</span>
<span class="sd">        3. The effective success probability for each gene in each cell is</span>
<span class="sd">           computed as p_hat = p * p_capture / (1 - p * (1 - p_capture))</span>
<span class="sd">        4. The mixture is handled using Numpyro&#39;s MixtureSameFamily</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int</span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    model_config : ModelConfig</span>
<span class="sd">        Configuration object for model distributions containing:</span>
<span class="sd">            - mixing_distribution_model: Distribution for mixture weights</span>
<span class="sd">            - p_distribution_model: Distribution for success probability p</span>
<span class="sd">            - r_distribution_model: Distribution for dispersion parameters r</span>
<span class="sd">            - p_capture_distribution_model: Distribution for capture</span>
<span class="sd">              probabilities</span>
<span class="sd">    counts : array-like, optional</span>
<span class="sd">        Observed counts matrix of shape (n_cells, n_genes). If None, generates</span>
<span class="sd">        samples from the prior.</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic optimization. If None, uses full dataset.</span>

<span class="sd">    Model Structure</span>
<span class="sd">    --------------</span>
<span class="sd">    Global Parameters:</span>
<span class="sd">        - Mixture weights ~ model_config.mixing_distribution_model</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_model</span>
<span class="sd">        - Component-specific dispersion r ~ model_config.r_distribution_model</span>
<span class="sd">          per gene</span>

<span class="sd">    Local Parameters:</span>
<span class="sd">        - Cell-specific capture probabilities p_capture ~</span>
<span class="sd">          model_config.p_capture_distribution_model</span>
<span class="sd">        - Effective probability p_hat = p * p_capture / (1 - p * (1 -</span>
<span class="sd">          p_capture))</span>

<span class="sd">    Likelihood: counts ~ MixtureSameFamily(</span>
<span class="sd">        Categorical(mixing_weights), NegativeBinomial(r, p_hat)</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Sample mixing weights from Dirichlet prior</span>
    <span class="n">mixing_probs</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_model</span>
    <span class="p">)</span>
    
    <span class="c1"># Create mixing distribution</span>
    <span class="n">mixing_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">probs</span><span class="o">=</span><span class="n">mixing_probs</span><span class="p">)</span>

    <span class="c1"># Define the prior on the p parameters - one for each component</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_model</span><span class="p">)</span>

    <span class="c1"># Define the prior on the r parameters - one for each gene and component</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_model</span><span class="o">.</span><span class="n">expand</span><span class="p">([</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># If we have observed data, condition on it</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If batch size is not provided, use the entire dataset</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
                <span class="c1"># Sample cell-specific capture probabilities</span>
                <span class="n">p_capture</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                    <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_model</span>
                <span class="p">)</span>

                <span class="c1"># Reshape p_capture for broadcasting with components</span>
                <span class="n">p_capture_reshaped</span> <span class="o">=</span> <span class="n">p_capture</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [cells, 1, 1]</span>
                
                <span class="c1"># Compute effective probability for each component</span>
                <span class="n">p_hat</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">deterministic</span><span class="p">(</span>
                    <span class="s2">&quot;p_hat&quot;</span><span class="p">,</span>
                    <span class="n">p</span> <span class="o">*</span> <span class="n">p_capture_reshaped</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture_reshaped</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="c1"># Create base negative binomial distribution</span>
                <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Create mixture distribution</span>
                <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">base_dist</span><span class="p">)</span>
                
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mini-batch version</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span>
                <span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">,</span> <span class="n">subsample_size</span><span class="o">=</span><span class="n">batch_size</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">idx</span><span class="p">:</span>
                <span class="c1"># Sample cell-specific capture probabilities</span>
                <span class="n">p_capture</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                    <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_model</span>
                <span class="p">)</span>

                <span class="c1"># Reshape p_capture for broadcasting with components</span>
                <span class="n">p_capture_reshaped</span> <span class="o">=</span> <span class="n">p_capture</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [cells, 1, 1]</span>
                
                <span class="c1"># Compute effective probability for each component</span>
                <span class="n">p_hat</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">deterministic</span><span class="p">(</span>
                    <span class="s2">&quot;p_hat&quot;</span><span class="p">,</span>
                    <span class="n">p</span> <span class="o">*</span> <span class="n">p_capture_reshaped</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture_reshaped</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="c1"># Create base negative binomial distribution</span>
                <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Create mixture distribution</span>
                <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">base_dist</span><span class="p">)</span>
                
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Predictive model (no obs)</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
            <span class="c1"># Sample cell-specific capture probabilities</span>
            <span class="n">p_capture</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_model</span>
            <span class="p">)</span>

            <span class="c1"># Reshape p_capture for broadcasting with components</span>
            <span class="n">p_capture_reshaped</span> <span class="o">=</span> <span class="n">p_capture</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [cells, 1, 1]</span>
            
            <span class="c1"># Compute effective probability for each component</span>
            <span class="n">p_hat</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">deterministic</span><span class="p">(</span>
                <span class="s2">&quot;p_hat&quot;</span><span class="p">,</span>
                <span class="n">p</span> <span class="o">*</span> <span class="n">p_capture_reshaped</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture_reshaped</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="c1"># Create base negative binomial distribution</span>
            <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Create mixture distribution</span>
            <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">base_dist</span><span class="p">)</span>
            
            <span class="c1"># Sample counts from mixture</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Variational Guide for Negative Binomial Mixture Model with Variable Capture</span>
<span class="c1"># Probability</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="nbvcp_mixture_guide">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.nbvcp_mixture_guide">[docs]</a>
<span class="k">def</span> <span class="nf">nbvcp_mixture_guide</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Variational guide for the Negative Binomial mixture model with variable</span>
<span class="sd">    capture probability (NBVCP). This guide function defines the form of the</span>
<span class="sd">    variational distribution that will be optimized to approximate the true</span>
<span class="sd">    posterior.</span>

<span class="sd">    This guide function specifies a mean-field variational family where each</span>
<span class="sd">    parameter has an independent variational distribution specified in the</span>
<span class="sd">    model_config:</span>
<span class="sd">        - Mixing weights ~ model_config.mixing_distribution_guide</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_guide</span>
<span class="sd">        - Component-specific dispersion r ~ model_config.r_distribution_guide</span>
<span class="sd">          per gene and component</span>
<span class="sd">        - Cell-specific capture probability p_capture ~</span>
<span class="sd">          model_config.p_capture_distribution_guide</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int</span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    model_config : ModelConfig</span>
<span class="sd">        Configuration object containing variational distribution specifications:</span>
<span class="sd">            - mixing_distribution_guide: Distribution for mixture weights</span>
<span class="sd">            - p_distribution_guide: Distribution for success probability p</span>
<span class="sd">            - r_distribution_guide: Distribution for dispersion parameters r</span>
<span class="sd">            - p_capture_distribution_guide: Distribution for capture</span>
<span class="sd">              probabilities</span>
<span class="sd">    counts : array-like, optional</span>
<span class="sd">        Observed counts matrix of shape (n_cells, n_genes)</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic variational inference</span>

<span class="sd">    Guide Structure</span>
<span class="sd">    --------------</span>
<span class="sd">    Variational Parameters:</span>
<span class="sd">        - Mixing weights ~ model_config.mixing_distribution_guide</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_guide</span>
<span class="sd">        - Component-specific dispersion r ~ model_config.r_distribution_guide</span>
<span class="sd">          per gene and component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Extract mixing distribution values</span>
    <span class="n">mixing_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract mixing distribution parameters and constraints</span>
    <span class="n">mixing_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">mixing_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">mixing_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">mixing_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;mixing_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">mixing_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract p distribution values</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract p distribution parameters and constraints</span>
    <span class="n">p_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">p_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">p_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;p_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">p_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract r distribution values</span>
    <span class="n">r_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract r distribution parameters and constraints </span>
    <span class="n">r_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">r_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">r_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;r_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">))</span> <span class="o">*</span> <span class="n">r_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Sample global parameters outside the plate</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span> 
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">mixing_params</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">p_params</span><span class="p">))</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">r_params</span><span class="p">))</span>

    <span class="c1"># Extract p_capture distribution values</span>
    <span class="n">p_capture_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract p_capture distribution parameters and constraints</span>
    <span class="n">p_capture_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">p_capture_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">p_capture_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p_capture_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;p_capture_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_cells</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_capture_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Use plate for handling local parameters (p_capture)</span>
    <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span> 
                <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">p_capture_params</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span>
            <span class="s2">&quot;cells&quot;</span><span class="p">,</span>
            <span class="n">n_cells</span><span class="p">,</span>
            <span class="n">subsample_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">idx</span><span class="p">:</span>
            <span class="c1"># Index the parameters before creating the distribution</span>
            <span class="n">batch_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">param</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">p_capture_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">batch_params</span><span class="p">)</span>
            <span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Zero-Inflated Negative Binomial Mixture Model with Variable Capture</span>
<span class="c1"># Probability</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="zinbvcp_mixture_model">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.zinbvcp_mixture_model">[docs]</a>
<span class="k">def</span> <span class="nf">zinbvcp_mixture_model</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zero-Inflated Negative Binomial Mixture Model with Variable Capture</span>
<span class="sd">    Probability for single-cell RNA sequencing data.</span>

<span class="sd">    This model captures key characteristics of scRNA-seq data including:</span>
<span class="sd">        - Technical dropouts via zero-inflation</span>
<span class="sd">        - Cell-specific capture efficiencies</span>
<span class="sd">        - Overdispersion via negative binomial distribution</span>
<span class="sd">        - Heterogeneous cell populations via mixture components</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int </span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    model_config : ModelConfig</span>
<span class="sd">        Configuration object for model distributions containing:</span>
<span class="sd">            - mixing_distribution_model: Distribution for mixture weights</span>
<span class="sd">            - p_distribution_model: Distribution for success probability p</span>
<span class="sd">            - r_distribution_model: Distribution for dispersion parameters r</span>
<span class="sd">            - gate_distribution_model: Distribution for dropout probabilities</span>
<span class="sd">            - p_capture_distribution_model: Distribution for capture</span>
<span class="sd">              probabilities</span>
<span class="sd">    counts : array-like, optional</span>
<span class="sd">        Observed counts matrix of shape (n_cells, n_genes). If None, generates</span>
<span class="sd">        samples from the prior.</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic optimization. If None, uses full dataset.</span>

<span class="sd">    Model Structure</span>
<span class="sd">    --------------</span>
<span class="sd">    Global Parameters:</span>
<span class="sd">        - Mixture weights ~ model_config.mixing_distribution_model</span>
<span class="sd">        - Success probability p ~ model_config.p_distribution_model</span>
<span class="sd">        - Component-specific dispersion r ~ model_config.r_distribution_model</span>
<span class="sd">          per gene</span>
<span class="sd">        - Dropout probabilities gate ~ model_config.gate_distribution_model per</span>
<span class="sd">          gene</span>

<span class="sd">    Local Parameters:</span>
<span class="sd">        - Cell-specific capture probabilities p_capture ~</span>
<span class="sd">          model_config.p_capture_distribution_model</span>
<span class="sd">        - Effective probability p_hat = p * p_capture / (1 - p * (1 -</span>
<span class="sd">          p_capture))</span>

<span class="sd">    Likelihood: counts ~ MixtureSameFamily(</span>
<span class="sd">        Categorical(mixing_weights), ZeroInflatedNegativeBinomial(r, p_hat,</span>
<span class="sd">        gate)</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Sample mixing weights from Dirichlet prior</span>
    <span class="n">mixing_probs</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_model</span>
    <span class="p">)</span>
    
    <span class="c1"># Create mixing distribution</span>
    <span class="n">mixing_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">probs</span><span class="o">=</span><span class="n">mixing_probs</span><span class="p">)</span>

    <span class="c1"># Define the prior on the p parameters - one for each component</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_model</span><span class="p">)</span>

    <span class="c1"># Define the prior on the r parameters - one for each gene and component</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;r&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_model</span><span class="o">.</span><span class="n">expand</span><span class="p">([</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">])</span>
    <span class="p">)</span>
    
    <span class="c1"># Define the prior on the gate parameters - one for each gene</span>
    <span class="n">gate</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;gate&quot;</span><span class="p">,</span>
        <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_model</span><span class="o">.</span><span class="n">expand</span><span class="p">([</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># If we have observed data, condition on it</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If batch size is not provided, use the entire dataset</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
                <span class="c1"># Sample cell-specific capture probabilities</span>
                <span class="n">p_capture</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                    <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_model</span>
                <span class="p">)</span>

                <span class="c1"># Reshape p_capture for broadcasting with components</span>
                <span class="n">p_capture_reshaped</span> <span class="o">=</span> <span class="n">p_capture</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [cells, 1, 1]</span>
                
                <span class="c1"># Compute effective probability for each component</span>
                <span class="n">p_hat</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">deterministic</span><span class="p">(</span>
                    <span class="s2">&quot;p_hat&quot;</span><span class="p">,</span>
                    <span class="n">p</span> <span class="o">*</span> <span class="n">p_capture_reshaped</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture_reshaped</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="c1"># Create base negative binomial distribution</span>
                <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                
                <span class="c1"># Create zero-inflated distribution</span>
                <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span>
                    <span class="n">base_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Create mixture distribution</span>
                <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">zinb</span><span class="p">)</span>
                
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span>
                <span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">,</span> <span class="n">subsample_size</span><span class="o">=</span><span class="n">batch_size</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">idx</span><span class="p">:</span>
                <span class="c1"># Sample cell-specific capture probabilities</span>
                <span class="n">p_capture</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                    <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_model</span>
                <span class="p">)</span>

                <span class="c1"># Reshape p_capture for broadcasting with components</span>
                <span class="n">p_capture_reshaped</span> <span class="o">=</span> <span class="n">p_capture</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [cells, 1, 1]</span>
                
                <span class="c1"># Compute effective probability for each component</span>
                <span class="n">p_hat</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">deterministic</span><span class="p">(</span>
                    <span class="s2">&quot;p_hat&quot;</span><span class="p">,</span>
                    <span class="n">p</span> <span class="o">*</span> <span class="n">p_capture_reshaped</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture_reshaped</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="c1"># Create base negative binomial distribution</span>
                <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                
                <span class="c1"># Create zero-inflated distribution</span>
                <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span>
                    <span class="n">base_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># Create mixture distribution</span>
                <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">zinb</span><span class="p">)</span>
                
                <span class="c1"># Sample counts from mixture</span>
                <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">counts</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
            <span class="c1"># Sample cell-specific capture probabilities</span>
            <span class="n">p_capture</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_model</span>
            <span class="p">)</span>

            <span class="c1"># Reshape p_capture for broadcasting with components</span>
            <span class="n">p_capture_reshaped</span> <span class="o">=</span> <span class="n">p_capture</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># [cells, 1, 1]</span>
            
            <span class="c1"># Compute effective probability for each component</span>
            <span class="n">p_hat</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">deterministic</span><span class="p">(</span>
                <span class="s2">&quot;p_hat&quot;</span><span class="p">,</span>
                <span class="n">p</span> <span class="o">*</span> <span class="n">p_capture_reshaped</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture_reshaped</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="c1"># Create base negative binomial distribution</span>
            <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            
            <span class="c1"># Create zero-inflated distribution</span>
            <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span>
                <span class="n">base_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span><span class="o">.</span><span class="n">to_event</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Create mixture distribution</span>
            <span class="n">mixture</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">MixtureSameFamily</span><span class="p">(</span><span class="n">mixing_dist</span><span class="p">,</span> <span class="n">zinb</span><span class="p">)</span>
            
            <span class="c1"># Sample counts from mixture</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">mixture</span><span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Variational Guide for Zero-Inflated Negative Binomial Mixture Model with</span>
<span class="c1"># Variable Capture Probability</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="zinbvcp_mixture_guide">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.zinbvcp_mixture_guide">[docs]</a>
<span class="k">def</span> <span class="nf">zinbvcp_mixture_guide</span><span class="p">(</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_genes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">model_config</span><span class="p">:</span> <span class="n">ModelConfig</span><span class="p">,</span>
    <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Variational guide for the Zero-Inflated Negative Binomial mixture model with</span>
<span class="sd">    variable capture probability.</span>

<span class="sd">    This guide specifies a mean-field variational family for approximating the</span>
<span class="sd">    posterior distribution of model parameters. The variational distributions</span>
<span class="sd">    are:</span>

<span class="sd">    Global Parameters:</span>
<span class="sd">        - Mixing weights ~ Dirichlet(alpha_mixing)</span>
<span class="sd">        - Success probability p ~ Beta(alpha_p, beta_p) [shared across</span>
<span class="sd">          components]</span>
<span class="sd">        - Component-specific dispersion r ~ Gamma(alpha_r, beta_r) [per</span>
<span class="sd">          component and gene]</span>
<span class="sd">        - Dropout probabilities gate ~ Beta(alpha_gate, beta_gate) [per gene]</span>

<span class="sd">    Local Parameters:</span>
<span class="sd">        - Cell-specific capture probabilities p_capture ~ Beta(alpha_p_capture,</span>
<span class="sd">          beta_p_capture) [per cell]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_cells : int</span>
<span class="sd">        Number of cells in the dataset</span>
<span class="sd">    n_genes : int</span>
<span class="sd">        Number of genes in the dataset</span>
<span class="sd">    n_components : int</span>
<span class="sd">        Number of mixture components</span>
<span class="sd">    p_prior : tuple, default=(1, 1)</span>
<span class="sd">        Beta prior parameters (alpha, beta) for success probability p</span>
<span class="sd">    r_prior : tuple, default=(2, 0.1)</span>
<span class="sd">        Gamma prior parameters (shape, rate) for dispersion r</span>
<span class="sd">    p_capture_prior : tuple, default=(1, 1)</span>
<span class="sd">        Beta prior parameters for cell-specific capture probabilities</span>
<span class="sd">    gate_prior : tuple, default=(1, 1)</span>
<span class="sd">        Beta prior parameters for gene-specific dropout probabilities</span>
<span class="sd">    mixing_prior : float or tuple, default=1.0</span>
<span class="sd">        Dirichlet prior concentration parameter(s) for mixture weights</span>
<span class="sd">    counts : array_like, optional</span>
<span class="sd">        Observed count matrix of shape (n_cells, n_genes)</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        Mini-batch size for stochastic variational inference. If None, uses full</span>
<span class="sd">        dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract number of components</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">n_components</span>

    <span class="c1"># Extract mixing distribution values</span>
    <span class="n">mixing_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract mixing distribution parameters and constraints</span>
    <span class="n">mixing_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">mixing_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">mixing_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">mixing_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;mixing_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">mixing_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract p distribution values</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract p distribution parameters and constraints</span>
    <span class="n">p_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">p_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">p_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;p_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">p_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Extract r distribution values</span>
    <span class="n">r_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract r distribution parameters and constraints </span>
    <span class="n">r_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">r_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">r_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;r_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">))</span> <span class="o">*</span> <span class="n">r_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>
    <span class="c1"># Extract gate distribution values</span>
    <span class="n">gate_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract gate distribution parameters and constraints</span>
    <span class="n">gate_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">gate_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">gate_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">gate_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;gate_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_genes</span><span class="p">))</span> <span class="o">*</span> <span class="n">gate_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>
    
    <span class="c1"># Sample global parameters outside the plate</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;mixing_weights&quot;</span><span class="p">,</span> 
        <span class="n">model_config</span><span class="o">.</span><span class="n">mixing_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">mixing_params</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">p_params</span><span class="p">))</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">model_config</span><span class="o">.</span><span class="n">r_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">r_params</span><span class="p">))</span>
    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="s2">&quot;gate&quot;</span><span class="p">,</span> 
        <span class="n">model_config</span><span class="o">.</span><span class="n">gate_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">gate_params</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Extract p_capture distribution values</span>
    <span class="n">p_capture_values</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="n">get_args</span><span class="p">()</span>
    <span class="c1"># Extract p_capture distribution parameters and constraints</span>
    <span class="n">p_capture_constraints</span> <span class="o">=</span> <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="n">arg_constraints</span>
    <span class="c1"># Initialize parameters for each constraint in the distribution</span>
    <span class="n">p_capture_params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Loop through each constraint in the distribution</span>
    <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">p_capture_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p_capture_params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;p_capture_</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_cells</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_capture_values</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span>
            <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span>
        <span class="p">)</span>

    <span class="c1"># Use plate for handling local parameters (p_capture)</span>
    <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">):</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span> 
                <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">p_capture_params</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">plate</span><span class="p">(</span>
            <span class="s2">&quot;cells&quot;</span><span class="p">,</span>
            <span class="n">n_cells</span><span class="p">,</span>
            <span class="n">subsample_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">idx</span><span class="p">:</span>
            <span class="c1"># Index the parameters before creating the distribution</span>
            <span class="n">batch_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">param</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">p_capture_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                <span class="s2">&quot;p_capture&quot;</span><span class="p">,</span>
                <span class="n">model_config</span><span class="o">.</span><span class="n">p_capture_distribution_guide</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">batch_params</span><span class="p">)</span>
            <span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Log Likelihood functions</span>
<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Negative Binomial Dirichlet Multinomial Mixture Model</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="nbdm_mixture_log_likelihood">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.nbdm_mixture_log_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">nbdm_mixture_log_likelihood</span><span class="p">(</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cells_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">return_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span>
    <span class="n">split_components</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute log likelihood for NBDM mixture model using independent negative</span>
<span class="sd">    binomials.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    counts : jnp.ndarray</span>
<span class="sd">        Array of shape (n_cells, n_genes) containing observed counts</span>
<span class="sd">    params : Dict</span>
<span class="sd">        Dictionary containing model parameters:</span>
<span class="sd">            - &#39;mixing_weights&#39;: probabilities for each component</span>
<span class="sd">            - &#39;p&#39;: success probability parameter</span>
<span class="sd">            - &#39;r&#39;: dispersion parameters for each gene and component</span>
<span class="sd">    batch_size : Optional[int]</span>
<span class="sd">        Size of mini-batches for stochastic computation. If None, uses full</span>
<span class="sd">        dataset.</span>
<span class="sd">    cells_axis: int = 0</span>
<span class="sd">        Axis along which cells are arranged. 0 means cells are rows (default), 1</span>
<span class="sd">        means cells are columns</span>
<span class="sd">    return_by: str</span>
<span class="sd">        Specifies how to return the log probabilities. Must be one of:</span>
<span class="sd">            - &#39;cell&#39;: returns log probabilities summed over genes (default)</span>
<span class="sd">            - &#39;gene&#39;: returns log probabilities summed over cells</span>
<span class="sd">    split_components: bool = False</span>
<span class="sd">        If True, returns separate log probabilities for each component. If</span>
<span class="sd">        False, returns the log probability of the mixture.</span>
<span class="sd">    weights: Optional[jnp.ndarray]</span>
<span class="sd">        Array of shape (n_genes,) containing weights for each gene. If None,</span>
<span class="sd">        weights are not used.</span>
<span class="sd">    weight_type: Optional[str] = None</span>
<span class="sd">        How to apply weights to probabilities. Must be one of:</span>
<span class="sd">            - &#39;multiplicative&#39;: applies as p^weight (weight * log(p) in log</span>
<span class="sd">              space)</span>
<span class="sd">            - &#39;additive&#39;: applies as exp(weight)*p (weight + log(p) in log space)</span>
<span class="sd">    dtype: jnp.dtype, default=jnp.float32</span>
<span class="sd">        Data type for numerical precision in computations</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        Shape depends on return_by and split_components:</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=False: shape (n_cells,)</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=True: shape (n_cells,</span>
<span class="sd">              n_components)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=False: shape (n_genes,)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=True: shape (n_genes,</span>
<span class="sd">              n_components)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if counts is already a jnp.ndarray with the correct dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">counts</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="c1"># Only allocate a new array if necessary</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Check return_by and weight_type</span>
    <span class="k">if</span> <span class="n">return_by</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;gene&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_by must be one of [&#39;cell&#39;, &#39;gene&#39;]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weight_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;multiplicative&#39;</span><span class="p">,</span> <span class="s1">&#39;additive&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight_type must be one of &quot;</span>
                         <span class="s2">&quot;[&#39;multiplicative&#39;, &#39;additive&#39;]&quot;</span><span class="p">)</span>

    <span class="c1"># Extract parameters</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_components, n_genes)</span>
    <span class="n">mixing_weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;mixing_weights&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">mixing_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Extract dimensions</span>
    <span class="k">if</span> <span class="n">cells_axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_cells</span><span class="p">,</span> <span class="n">n_genes</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_genes</span><span class="p">,</span> <span class="n">n_cells</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>  <span class="c1"># Transpose to make cells rows</span>

    <span class="c1"># Expand dimensions for vectorized computation</span>
    <span class="c1"># counts: (n_cells, n_genes) -&gt; (n_cells, n_genes, 1)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># r: (n_components, n_genes) -&gt; (1, n_genes, n_components)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># p: scalar -&gt; (1, 1, 1) for broadcasting</span>
    <span class="c1"># First convert scalar to array, then add dimensions</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  

    <span class="c1"># Create base NB distribution vectorized over cells, components, genes</span>
    <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="c1"># Validate and process weights</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">expected_length</span> <span class="o">=</span> <span class="n">n_genes</span> <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="k">else</span> <span class="n">n_cells</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;For return_by=&#39;</span><span class="si">{</span><span class="n">return_by</span><span class="si">}</span><span class="s2">&#39;, weights must be of shape &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">expected_length</span><span class="si">}</span><span class="s2">,)&quot;</span>
            <span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute log probs for all cells at once</span>
            <span class="c1"># This gives (n_cells, n_components, n_genes)</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for results</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                
                <span class="c1"># Compute log probs for batch</span>
                <span class="c1"># Shape: (batch_size, n_components, n_genes)</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                
                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
                <span class="c1"># Store log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">=</span> <span class="n">log_probs</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># return_by == &#39;gene&#39;</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute log probs for each gene</span>
            <span class="c1"># Shape: (n_cells, n_components, n_genes)</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over cells and add mixing weights</span>
            <span class="c1"># Shape: (n_genes, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for results</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                
                <span class="c1"># Compute log probs for batch</span>
                <span class="c1"># Shape: (batch_size, n_components, n_genes)</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>  
                
                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Add weighted log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Add mixing weights</span>
            <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">split_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">log_probs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jsp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Zero-Inflated Negative Binomial Mixture Model</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="zinb_mixture_log_likelihood">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.zinb_mixture_log_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">zinb_mixture_log_likelihood</span><span class="p">(</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cells_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">return_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span>
    <span class="n">split_components</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute log likelihood for ZINB mixture model.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    counts : jnp.ndarray</span>
<span class="sd">        Array of shape (n_cells, n_genes) containing observed counts</span>
<span class="sd">    params : Dict</span>
<span class="sd">        Dictionary containing model parameters:</span>
<span class="sd">            - &#39;mixing_weights&#39;: probabilities for each component</span>
<span class="sd">            - &#39;p&#39;: success probability parameter</span>
<span class="sd">            - &#39;r&#39;: dispersion parameters for each gene and component</span>
<span class="sd">            - &#39;gate&#39;: dropout probabilities for each gene and component</span>
<span class="sd">    batch_size : Optional[int]</span>
<span class="sd">        Size of mini-batches for stochastic computation. If None, uses full dataset.</span>
<span class="sd">    cells_axis: int = 0</span>
<span class="sd">        Axis along which cells are arranged. 0 means cells are rows (default),</span>
<span class="sd">        1 means cells are columns</span>
<span class="sd">    return_by: str</span>
<span class="sd">        Specifies how to return the log probabilities. Must be one of:</span>
<span class="sd">            - &#39;cell&#39;: returns log probabilities summed over genes (default)</span>
<span class="sd">            - &#39;gene&#39;: returns log probabilities summed over cells</span>
<span class="sd">    split_components: bool = False</span>
<span class="sd">        If True, returns separate log probabilities for each component.</span>
<span class="sd">        If False, returns the log probability of the mixture.</span>
<span class="sd">    weights: Optional[jnp.ndarray]</span>
<span class="sd">        Array of shape (n_genes,) containing weights for each gene. If None,</span>
<span class="sd">        weights are not used.</span>
<span class="sd">    weight_type: Optional[str] = None</span>
<span class="sd">        How to apply weights to probabilities. Must be one of:</span>
<span class="sd">            - &#39;multiplicative&#39;: applies as p^weight (weight * log(p) in log space)</span>
<span class="sd">            - &#39;additive&#39;: applies as exp(weight)*p (weight + log(p) in log space)</span>
<span class="sd">    dtype: jnp.dtype, default=jnp.float32</span>
<span class="sd">        Data type for numerical precision in computations</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        Shape depends on return_by and split_components:</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=False: shape (n_cells,)</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=True: shape (n_cells, n_components)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=False: shape (n_genes,)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=True: shape (n_genes, n_components)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if counts is already a jnp.ndarray with the correct dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">counts</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="c1"># Only allocate a new array if necessary</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Check return_by and weight_type</span>
    <span class="k">if</span> <span class="n">return_by</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;gene&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_by must be one of [&#39;cell&#39;, &#39;gene&#39;]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weight_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;multiplicative&#39;</span><span class="p">,</span> <span class="s1">&#39;additive&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight_type must be one of &quot;</span>
                         <span class="s2">&quot;[&#39;multiplicative&#39;, &#39;additive&#39;]&quot;</span><span class="p">)</span>

    <span class="c1"># Extract parameters</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_components, n_genes)</span>
    <span class="n">gate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;gate&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_components, n_genes)</span>
    <span class="n">mixing_weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;mixing_weights&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">mixing_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Extract dimensions</span>
    <span class="k">if</span> <span class="n">cells_axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_cells</span><span class="p">,</span> <span class="n">n_genes</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_genes</span><span class="p">,</span> <span class="n">n_cells</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="c1"># Transpose to make cells rows</span>


    <span class="c1"># Expand dimensions for vectorized computation</span>
    <span class="c1"># counts: (n_cells, n_genes) -&gt; (n_cells, n_genes, 1)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># r: (n_components, n_genes) -&gt; (1, n_genes, n_components)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># gate: (n_components, n_genes) -&gt; (1, n_components, n_genes)</span>
    <span class="n">gate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gate</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># p: scalar -&gt; (1, 1, 1) for broadcasting</span>
    <span class="c1"># First convert scalar to array, then add dimensions</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  

    <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
    <span class="c1"># r: (1, n_genes, n_components)</span>
    <span class="c1"># p: (1, 1, 1) or scalar</span>
    <span class="c1"># counts: (n_cells, n_genes, 1)</span>
    <span class="c1"># This will broadcast to: (n_cells, n_genes, n_components)</span>
    <span class="n">base_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="c1"># Create zero-inflated distribution for each component</span>
    <span class="c1"># This will broadcast to: (n_cells, n_genes, n_components)</span>
    <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span><span class="n">base_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span>

    <span class="c1"># Validate and process weights</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">expected_length</span> <span class="o">=</span> <span class="n">n_genes</span> <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="k">else</span> <span class="n">n_cells</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;For return_by=&#39;</span><span class="si">{</span><span class="n">return_by</span><span class="si">}</span><span class="s2">&#39;, weights must be of shape &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">expected_length</span><span class="si">}</span><span class="s2">,)&quot;</span>
            <span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute log probs for all cells at once</span>
            <span class="c1"># This gives (n_cells, n_components, n_genes)</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for results</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="c1"># Get start and end indices for batch</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                
                <span class="c1"># Compute log probs for batch</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                
                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
                <span class="c1"># Store log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">=</span> <span class="n">log_probs</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># return_by == &#39;gene&#39;</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute log probs for each gene</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over cells and add mixing weights</span>
            <span class="c1"># Shape: (n_genes, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for results</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                
                <span class="c1"># Compute log probs for batch</span>
                <span class="c1"># Shape: (batch_size, n_components, n_genes)</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>  
                
                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Add weighted log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Add mixing weights</span>
            <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            
    <span class="k">if</span> <span class="n">split_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">log_probs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jsp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Negative Binomial Mixture Model with Capture Probabilities</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="nbvcp_mixture_log_likelihood">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.nbvcp_mixture_log_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">nbvcp_mixture_log_likelihood</span><span class="p">(</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cells_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">return_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span>
    <span class="n">split_components</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute log likelihood for NBVCP mixture model.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    counts : jnp.ndarray</span>
<span class="sd">        Array of shape (n_cells, n_genes) containing observed counts</span>
<span class="sd">    params : Dict</span>
<span class="sd">        Dictionary containing model parameters:</span>
<span class="sd">            - &#39;mixing_weights&#39;: probabilities for each component</span>
<span class="sd">            - &#39;p&#39;: base success probability parameter</span>
<span class="sd">            - &#39;r&#39;: dispersion parameters for each gene and component</span>
<span class="sd">            - &#39;p_capture&#39;: cell-specific capture probabilities</span>
<span class="sd">    batch_size : Optional[int]</span>
<span class="sd">        Size of mini-batches for stochastic computation. If None, uses full</span>
<span class="sd">        dataset.</span>
<span class="sd">    cells_axis: int = 0</span>
<span class="sd">        Axis along which cells are arranged. 0 means cells are rows (default), 1</span>
<span class="sd">        means cells are columns</span>
<span class="sd">    return_by: str</span>
<span class="sd">        Specifies how to return the log probabilities. Must be one of:</span>
<span class="sd">            - &#39;cell&#39;: returns log probabilities summed over genes (default)</span>
<span class="sd">            - &#39;gene&#39;: returns log probabilities summed over cells</span>
<span class="sd">    split_components: bool = False</span>
<span class="sd">        If True, returns separate log probabilities for each component. If</span>
<span class="sd">        False, returns the log probability of the mixture.</span>
<span class="sd">    weights: Optional[jnp.ndarray]</span>
<span class="sd">        Array of shape (n_genes,) containing weights for each gene. If None,</span>
<span class="sd">        weights are not used.</span>
<span class="sd">    weight_type: Optional[str] = None</span>
<span class="sd">        How to apply weights to probabilities. Must be one of:</span>
<span class="sd">            - &#39;multiplicative&#39;: applies as p^weight (weight * log(p) in log</span>
<span class="sd">              space)</span>
<span class="sd">            - &#39;additive&#39;: applies as exp(weight)*p (weight + log(p) in log space)</span>
<span class="sd">    dtype: jnp.dtype, default=jnp.float32</span>
<span class="sd">        Data type for numerical precision in computations</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        Shape depends on return_by and split_components:</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=False: shape (n_cells,)</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=True: shape (n_cells,</span>
<span class="sd">              n_components)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=False: shape (n_genes,)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=True: shape (n_genes,</span>
<span class="sd">              n_components)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if counts is already a jnp.ndarray with the correct dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">counts</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="c1"># Only allocate a new array if necessary</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Check return_by and weight_type</span>
    <span class="k">if</span> <span class="n">return_by</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;gene&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_by must be one of [&#39;cell&#39;, &#39;gene&#39;]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weight_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;multiplicative&#39;</span><span class="p">,</span> <span class="s1">&#39;additive&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight_type must be one of &quot;</span>
                         <span class="s2">&quot;[&#39;multiplicative&#39;, &#39;additive&#39;]&quot;</span><span class="p">)</span>

    <span class="c1"># Extract parameters</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_components, n_genes)</span>
    <span class="n">p_capture</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;p_capture&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_cells,)</span>
    <span class="n">mixing_weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;mixing_weights&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">mixing_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Extract dimensions</span>
    <span class="k">if</span> <span class="n">cells_axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_cells</span><span class="p">,</span> <span class="n">n_genes</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_genes</span><span class="p">,</span> <span class="n">n_cells</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="c1"># Transpose to make cells rows</span>

    <span class="c1"># Expand dimensions for vectorized computation</span>
    <span class="c1"># counts: (n_cells, n_genes) -&gt; (n_cells, n_genes, 1)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># r: (n_components, n_genes) -&gt; (1, n_genes, n_components)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># p_capture: (n_cells,) -&gt; (n_cells, 1, 1) for broadcasting</span>
    <span class="n">p_capture</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">p_capture</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># p: scalar -&gt; (1, 1, 1) for broadcasting</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="c1"># Compute effective probability for each cell</span>
    <span class="c1"># This will broadcast to shape (n_cells, 1, 1)</span>
    <span class="n">p_hat</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_capture</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture</span><span class="p">))</span>

    <span class="c1"># Validate and process weights</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">expected_length</span> <span class="o">=</span> <span class="n">n_genes</span> <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="k">else</span> <span class="n">n_cells</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;For return_by=&#39;</span><span class="si">{</span><span class="n">return_by</span><span class="si">}</span><span class="s2">&#39;, weights must be of shape &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">expected_length</span><span class="si">}</span><span class="s2">,)&quot;</span>
            <span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
            <span class="c1"># r: (1, n_genes, n_components)</span>
            <span class="c1"># p_hat: (n_cells, 1, 1) or scalar</span>
            <span class="c1"># counts: (n_cells, n_genes, 1)</span>
            <span class="c1"># This will broadcast to: (n_cells, n_genes, n_components)</span>
            <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">)</span>

            <span class="c1"># Compute log probs for all cells at once</span>
            <span class="c1"># This gives (n_cells, n_components, n_genes)</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for results</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="c1"># Get start and end indices for batch</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
                <span class="c1"># r: (1, n_genes, n_components)</span>
                <span class="c1"># p_hat: (n_cells, 1, 1)</span>
                <span class="c1"># counts: (n_cells, n_genes, 1)</span>
                <span class="c1"># This will broadcast to: (batch_size, n_genes, n_components)</span>
                <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span>
                    <span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                <span class="c1"># Compute log probs for batch</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                
                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
                <span class="c1"># Store log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">=</span> <span class="n">log_probs</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
                <span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># return_by == &#39;gene&#39;</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
            <span class="c1"># r: (1, n_genes, n_components)</span>
            <span class="c1"># p_hat: (n_cells, 1, 1) or scalar</span>
            <span class="c1"># counts: (n_cells, n_genes, 1)</span>
            <span class="c1"># This will broadcast to: (n_cells, n_genes, n_components)</span>
            <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">)</span>
            <span class="c1"># Compute log probs for each gene</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over cells and add mixing weights</span>
            <span class="c1"># Shape: (n_genes, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for gene-wise sums</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="c1"># Get start and end indices for batch</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
                <span class="c1"># r: (1, n_genes, n_components)</span>
                <span class="c1"># p_hat: (n_cells, 1, 1)</span>
                <span class="c1"># counts: (n_cells, n_genes, 1)</span>
                <span class="c1"># This will broadcast to: (batch_size, n_genes, n_components)</span>
                <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span>
                    <span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                
                <span class="c1"># Compute log probs for batch</span>
                <span class="c1"># Shape: (batch_size, n_genes, n_components)</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">nb_dist</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>  

                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Add weighted log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Add mixing weights</span>
            <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            
    <span class="k">if</span> <span class="n">split_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">log_probs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jsp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># ------------------------------------------------------------------------------</span>
<span class="c1"># Zero-Inflated Negative Binomial Mixture Model with Capture Probabilities</span>
<span class="c1"># ------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="zinbvcp_mixture_log_likelihood">
<a class="viewcode-back" href="../../api/models_mix.html#scribe.models_mix.zinbvcp_mixture_log_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">zinbvcp_mixture_log_likelihood</span><span class="p">(</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cells_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">return_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span>
    <span class="n">split_components</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute log likelihood for ZINBVCP mixture model.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    counts : jnp.ndarray</span>
<span class="sd">        Array of shape (n_cells, n_genes) containing observed counts</span>
<span class="sd">    params : Dict</span>
<span class="sd">        Dictionary containing model parameters:</span>
<span class="sd">            - &#39;mixing_weights&#39;: probabilities for each component</span>
<span class="sd">            - &#39;p&#39;: base success probability parameter</span>
<span class="sd">            - &#39;r&#39;: dispersion parameters for each gene and component</span>
<span class="sd">            - &#39;p_capture&#39;: cell-specific capture probabilities</span>
<span class="sd">            - &#39;gate&#39;: dropout probabilities for each gene and component</span>
<span class="sd">    batch_size : Optional[int]</span>
<span class="sd">        Size of mini-batches for stochastic computation. If None, uses full</span>
<span class="sd">        dataset.</span>
<span class="sd">    cells_axis: int = 0</span>
<span class="sd">        Axis along which cells are arranged. 0 means cells are rows (default), 1</span>
<span class="sd">        means cells are columns</span>
<span class="sd">    return_by: str</span>
<span class="sd">        Specifies how to return the log probabilities. Must be one of:</span>
<span class="sd">            - &#39;cell&#39;: returns log probabilities summed over genes (default)</span>
<span class="sd">            - &#39;gene&#39;: returns log probabilities summed over cells</span>
<span class="sd">    split_components: bool = False</span>
<span class="sd">        If True, returns separate log probabilities for each component. If</span>
<span class="sd">        False, returns the log probability of the mixture.</span>
<span class="sd">    weights: Optional[jnp.ndarray]</span>
<span class="sd">        Array of shape (n_genes,) containing weights for each gene. If None,</span>
<span class="sd">        weights are not used.</span>
<span class="sd">    weight_type: Optional[str] = None</span>
<span class="sd">        How to apply weights. Must be one of:</span>
<span class="sd">            - &#39;multiplicative&#39;: multiply log probabilities by weights</span>
<span class="sd">            - &#39;additive&#39;: add weights to log probabilities</span>
<span class="sd">    dtype: jnp.dtype, default=jnp.float32</span>
<span class="sd">        Data type for numerical precision in computations</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        Shape depends on return_by and split_components:</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=False: shape (n_cells,)</span>
<span class="sd">            - return_by=&#39;cell&#39;, split_components=True: shape (n_cells,</span>
<span class="sd">              n_components)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=False: shape (n_genes,)</span>
<span class="sd">            - return_by=&#39;gene&#39;, split_components=True: shape (n_genes,</span>
<span class="sd">              n_components)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if counts is already a jnp.ndarray with the correct dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">counts</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="c1"># Only allocate a new array if necessary</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Check return_by and weight_type</span>
    <span class="k">if</span> <span class="n">return_by</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;gene&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_by must be one of [&#39;cell&#39;, &#39;gene&#39;]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weight_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;multiplicative&#39;</span><span class="p">,</span> <span class="s1">&#39;additive&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight_type must be one of &quot;</span>
                         <span class="s2">&quot;[&#39;multiplicative&#39;, &#39;additive&#39;]&quot;</span><span class="p">)</span>

    <span class="c1"># Extract parameters</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_components, n_genes)</span>
    <span class="n">p_capture</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;p_capture&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_cells,)</span>
    <span class="n">gate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;gate&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># shape (n_components, n_genes)</span>
    <span class="n">mixing_weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;mixing_weights&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">mixing_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Extract dimensions</span>
    <span class="k">if</span> <span class="n">cells_axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_cells</span><span class="p">,</span> <span class="n">n_genes</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_genes</span><span class="p">,</span> <span class="n">n_cells</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>  <span class="c1"># Transpose to make cells rows</span>


    <span class="c1"># Expand dimensions for vectorized computation</span>
    <span class="c1"># counts: (n_cells, n_genes) -&gt; (n_cells, n_genes, 1)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># r: (n_components, n_genes) -&gt; (1, n_genes, n_components)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># gate: (n_components, n_genes) -&gt; (1, n_genes, n_components)</span>
    <span class="n">gate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gate</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># p_capture: (n_cells,) -&gt; (n_cells, 1, 1) for broadcasting</span>
    <span class="n">p_capture</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">p_capture</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># p: scalar -&gt; (1, 1, 1) for broadcasting</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="c1"># Compute effective probability for each cell</span>
    <span class="c1"># This will broadcast to shape (n_cells, 1, 1)</span>
    <span class="n">p_hat</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_capture</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_capture</span><span class="p">))</span>

    <span class="c1"># Validate and process weights</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">expected_length</span> <span class="o">=</span> <span class="n">n_genes</span> <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="k">else</span> <span class="n">n_cells</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;For return_by=&#39;</span><span class="si">{</span><span class="n">return_by</span><span class="si">}</span><span class="s2">&#39;, weights must be of shape &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">expected_length</span><span class="si">}</span><span class="s2">,)&quot;</span>
            <span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_by</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
            <span class="c1"># r: (1, n_genes, n_components)</span>
            <span class="c1"># p_hat: (n_cells, 1, 1) or scalar</span>
            <span class="c1"># counts: (n_cells, n_genes, 1)</span>
                <span class="c1"># This will broadcast to: (n_cells, n_genes, n_components)</span>
            <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">)</span>
            <span class="c1"># Create zero-inflated distribution for each component</span>
            <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span><span class="n">nb_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span>
            <span class="c1"># Compute log probs for all cells at once</span>
            <span class="c1"># This gives (n_cells, n_components, n_genes)</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for results</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="c1"># Get start and end indices for batch</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
                <span class="c1"># r: (1, n_genes, n_components)</span>
                <span class="c1"># p_hat: (n_cells, 1, 1) or scalar</span>
                <span class="c1"># counts: (n_cells, n_genes, 1)</span>
                <span class="c1"># This will broadcast to: (batch_size, n_genes, n_components)</span>
                <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span>
                    <span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                <span class="c1"># Create zero-inflated distribution for each component</span>
                <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span>
                    <span class="n">nb_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span>
                <span class="c1"># Compute log probs for batch</span>
                <span class="c1"># Shape: (batch_size, n_genes, n_components)</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                
                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Sum over genes (axis=1) to get (n_cells, n_components)</span>
                <span class="c1"># Store log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">=</span> <span class="n">log_probs</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span>
                <span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># return_by == &#39;gene&#39;</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
            <span class="c1"># r: (1, n_genes, n_components)</span>
            <span class="c1"># p_hat: (n_cells, 1, 1) or scalar</span>
            <span class="c1"># counts: (n_cells, n_genes, 1)</span>
                <span class="c1"># This will broadcast to: (n_cells, n_genes, n_components)</span>
            <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">)</span>
            <span class="c1"># Create zero-inflated distribution for each component</span>
            <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span><span class="n">nb_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span>
            <span class="c1"># Compute log probs for each gene</span>
            <span class="n">gene_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            
            <span class="c1"># Apply weights based on weight_type</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                <span class="n">gene_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># Sum over cells and add mixing weights</span>
            <span class="c1"># Shape: (n_genes, n_components)</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gene_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize array for gene-wise sums</span>
            <span class="n">log_probs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_genes</span><span class="p">,</span> <span class="n">n_components</span><span class="p">))</span>
            
            <span class="c1"># Process in batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n_cells</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="c1"># Get start and end indices for batch</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
                <span class="c1"># Create base NB distribution vectorized over cells, genes, components</span>
                <span class="c1"># r: (1, n_genes, n_components)</span>
                <span class="c1"># p_hat: (n_cells, 1, 1) or scalar</span>
                <span class="c1"># counts: (n_cells, n_genes, 1)</span>
                <span class="c1"># This will broadcast to: (batch_size, n_genes, n_components)</span>
                <span class="n">nb_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">NegativeBinomialProbs</span><span class="p">(</span>
                    <span class="n">r</span><span class="p">,</span> <span class="n">p_hat</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>
                <span class="c1"># Create zero-inflated distribution for each component</span>
                <span class="n">zinb</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ZeroInflatedDistribution</span><span class="p">(</span>
                    <span class="n">nb_dist</span><span class="p">,</span> <span class="n">gate</span><span class="o">=</span><span class="n">gate</span><span class="p">)</span>
                <span class="c1"># Compute log probs for batch</span>
                <span class="c1"># Shape: (batch_size, n_genes, n_components)</span>
                <span class="n">batch_log_probs</span> <span class="o">=</span> <span class="n">zinb</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">])</span>

                <span class="c1"># Apply weights based on weight_type</span>
                <span class="k">if</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;multiplicative&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">*=</span> <span class="n">weights</span>
                <span class="k">elif</span> <span class="n">weight_type</span> <span class="o">==</span> <span class="s1">&#39;additive&#39;</span><span class="p">:</span>
                    <span class="n">batch_log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                
                <span class="c1"># Add weighted log probs for batch</span>
                <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">batch_log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Add mixing weights</span>
            <span class="n">log_probs</span> <span class="o">+=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mixing_weights</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            
    <span class="k">if</span> <span class="n">split_components</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">log_probs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jsp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">(</span><span class="n">log_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Manuel Razo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>